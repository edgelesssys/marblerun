/*
Copyright (c) Edgeless Systems GmbH

SPDX-License-Identifier: BUSL-1.1
*/

package distributor

import (
	"context"
	"sync"
	"testing"

	"github.com/stretchr/testify/assert"
	"go.uber.org/goleak"
	"go.uber.org/zap/zaptest"
)

func TestMain(m *testing.M) {
	goleak.VerifyTestMain(m)
}

func TestDistributor(t *testing.T) {
	testCases := map[string]struct {
		keyGenerator *stubKeyGenerator
		keyRetriever *stubKeyRetriever
		keySharer    *stubKeySharer
		stateLoader  *stubStateLoader
		generateKey  bool
		wantErr      bool
	}{
		"success: key already exists": {
			keyGenerator: &stubKeyGenerator{encryptionKey: []byte("key")},
			keyRetriever: &stubKeyRetriever{},
			keySharer:    &stubKeySharer{},
			stateLoader:  &stubStateLoader{},
		},
		"success: key from other instance": {
			keyGenerator: &stubKeyGenerator{exportKeyEncryptionKeyErr: assert.AnError},
			keyRetriever: &stubKeyRetriever{encryptionKey: []byte("key")},
			keySharer:    &stubKeySharer{},
			stateLoader:  &stubStateLoader{},
		},
		"success: key generated by this instance": {
			keyGenerator: &stubKeyGenerator{exportKeyEncryptionKeyErr: assert.AnError},
			keyRetriever: &stubKeyRetriever{},
			keySharer:    &stubKeySharer{},
			stateLoader:  &stubStateLoader{},
			generateKey:  true,
		},
		"error on SetKeyEncryptionKey does not cause failure": {
			keyGenerator: &stubKeyGenerator{
				exportKeyEncryptionKeyErr: assert.AnError,
				setKeyEncryptionKeyErr:    assert.AnError,
			},
			keyRetriever: &stubKeyRetriever{encryptionKey: []byte("key")},
			keySharer:    &stubKeySharer{},
			stateLoader:  &stubStateLoader{},
		},
		"running keysharer fails": {
			keyGenerator: &stubKeyGenerator{encryptionKey: []byte("key")},
			keyRetriever: &stubKeyRetriever{},
			keySharer:    &stubKeySharer{runErr: assert.AnError},
			stateLoader:  &stubStateLoader{},
			wantErr:      true,
		},
		"loading state fails": {
			keyGenerator: &stubKeyGenerator{exportKeyEncryptionKeyErr: assert.AnError},
			keyRetriever: &stubKeyRetriever{encryptionKey: []byte("key")},
			keySharer:    &stubKeySharer{},
			stateLoader:  &stubStateLoader{loadStateErr: assert.AnError},
			wantErr:      true,
		},
	}

	for name, tc := range testCases {
		t.Run(name, func(t *testing.T) {
			assert := assert.New(t)

			log := zaptest.NewLogger(t)

			d := New("", "", tc.keyGenerator, tc.keyRetriever, tc.keySharer, tc.stateLoader, log)

			var wg sync.WaitGroup
			var err error
			wg.Add(1)
			go func() {
				defer wg.Done()
				err = d.run()
			}()

			if tc.generateKey {
				d.keyChan <- []byte("key")
			}

			wg.Wait()

			if tc.wantErr {
				assert.Error(err)
				return
			}
			assert.NoError(err)
			assert.NotNil(tc.keySharer.key)

			if tc.keyGenerator.encryptionKey != nil {
				assert.False(tc.keyGenerator.SetKeyEncryptionKeyCalled)
				assert.False(tc.stateLoader.loadStateCalled)
				return
			}

			assert.True(tc.stateLoader.loadStateCalled)
			if tc.generateKey {
				assert.False(tc.keyGenerator.SetKeyEncryptionKeyCalled)
			} else {
				assert.True(tc.keyGenerator.SetKeyEncryptionKeyCalled)
			}
		})
	}
}

type stubKeyGenerator struct {
	encryptionKey             []byte
	exportKeyEncryptionKeyErr error
	SetKeyEncryptionKeyCalled bool
	setKeyEncryptionKeyErr    error
}

func (s *stubKeyGenerator) ExportKeyEncryptionKey(context.Context) ([]byte, error) {
	return s.encryptionKey, s.exportKeyEncryptionKeyErr
}

func (s *stubKeyGenerator) SetKeyEncryptionKey(context.Context, []byte) error {
	s.SetKeyEncryptionKeyCalled = true
	return s.setKeyEncryptionKeyErr
}

type stubKeyRetriever struct {
	encryptionKey []byte
}

func (s *stubKeyRetriever) Run(ctx context.Context, _, _ string) []byte {
	for {
		select {
		case <-ctx.Done():
			return nil
		default:
			if s.encryptionKey != nil {
				return s.encryptionKey
			}
		}
	}
}

type stubKeySharer struct {
	key    []byte
	runErr error
}

func (s *stubKeySharer) Run(key []byte, _ string) error {
	s.key = key
	return s.runErr
}

type stubStateLoader struct {
	loadStateCalled bool
	loadStateErr    error
}

func (s *stubStateLoader) LoadState() ([]byte, []byte, error) {
	s.loadStateCalled = true
	return nil, nil, s.loadStateErr
}

func (s *stubStateLoader) SetRecoveryData(_ []byte) {}
