/*
Copyright (c) Edgeless Systems GmbH

SPDX-License-Identifier: BUSL-1.1
*/

// Package seal provides a sealing interface for distributed Coordinators.
package seal

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"sync"

	"github.com/edgelesssys/ego/ecrypto"
	"github.com/edgelesssys/ego/enclave"
	"github.com/edgelesssys/marblerun/coordinator/kube"
	"github.com/edgelesssys/marblerun/coordinator/seal"
	"go.uber.org/zap"
	corev1 "k8s.io/api/core/v1"
	k8serrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
)

// Sealer provides functions to seal and unseal data.
// The Sealer uses a randomly generated key to seal the encryption key.
// This random key is sealed using the enclave's product or unique key, and saved to external storage.
/*
                             randomly generated by
                             Coordinator receiving        randomly generated at
                                 the Manifest                   start up
                               (can be updated)           (cannot be updated)
                                      │                           │
 ┌──────────────────┐        ┌────────▼──────────┐       ┌────────▼─────────┐
 │Coordinator state │        │Data Encryption Key│       │Key Encryption Key│
 └─────────┬────────┘        └───┬──┬────────────┘       └───────┬─────┬────┘
           ├─────────────────────┘  ├────────────────────────────┘     │
  ┌────────┼────────────────────────┼────────┐ ┌─────────────────────┐ │
  │        │ marblerun-state Secret │        │ │  KEK ConfigMap      │ │
  │ ┌──────▼─────────┐      ┌───────▼──────┐ │ │ ┌─────────────────┐ │ │ ┌──────────────┐
  │ │ Encrypted state│      │ Encrypted DEK│ │ │ │Node-1: enc(KEK) ◄─┼─┼─┤Node-1 SGX Key│
  │ └────────────────┘      └──────────────┘ │ │ └─────────────────┘ │ │ └──────────────┘
  └──────────────────────────────────────────┘ │ ┌─────────────────┐ │ │ ┌──────────────┐
                                               │ │Node-2: enc(KEK) ◄─┼─┼─┤Node-2 SGX Key│
                                               │ └─────────────────┘ │ │ └──────────────┘
                                               │        ...          │...          ...
                                               │ ┌─────────────────┐ │ │ ┌──────────────┐
                                               │ │Node-X: enc(KEK) ◄─┼─┴─┤Node-X SGX Key│
                                               │ └─────────────────┘ │   └──────────────┘
                                               └─────────────────────┘
*/
type Sealer struct {
	seal.Sealer

	sealWithProductKey sealFunc
	sealWithUniqueKey  sealFunc
	unseal             func(ciphertext, extraData []byte) ([]byte, error)
	unsealFallBack     func(ciphertext, extraData []byte) ([]byte, error)
	mode               seal.Mode
	keyEncryptionKey   []byte
	encryptionKey      []byte
	keyHandler         keyHandler
	log                *zap.Logger

	mux sync.Mutex
}

// New creates a new Sealer.
func New(sealer seal.Sealer, configMapName, namespace string, log *zap.Logger) (*Sealer, error) {
	client, err := kube.GetClient()
	if err != nil {
		return nil, err
	}

	keyHandler, err := newK8sKeyHandler(&kubeClient{client: client}, configMapName, namespace, log)
	if err != nil {
		return nil, err
	}

	return &Sealer{
		Sealer:             sealer,
		keyHandler:         keyHandler,
		sealWithProductKey: ecrypto.SealWithProductKey256,
		sealWithUniqueKey:  ecrypto.SealWithUniqueKey256,
		unseal:             ecrypto.Unseal256,
		unsealFallBack:     ecrypto.Unseal,
		log:                log,
	}, nil
}

// ExportKeyEncryptionKey seals the KEK to distributed storage.
// The KEK is returned for sharing with other instances.
func (s *Sealer) ExportKeyEncryptionKey(ctx context.Context) ([]byte, error) {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Exporting key encryption key")

	// Can't export keys if they are not set
	if s.keyEncryptionKey == nil {
		s.log.Debug("Unable to export key encryption key: no key set")
		return nil, errors.New("KEK not set")
	}

	if err := s.sealKEK(ctx); err != nil {
		return nil, fmt.Errorf("exporting KEK: %w", err)
	}

	return s.keyEncryptionKey, nil
}

// SetKeyEncryptionKey sets the key encryption key and seals it to distributed storage.
func (s *Sealer) SetKeyEncryptionKey(ctx context.Context, kek []byte) error {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Setting key encryption key")

	s.keyEncryptionKey = kek

	return s.sealKEK(ctx)
}

// UnsealEncryptionKey unseals the encryption key using the key encryption key.
// The KEK is stored in a ConfigMap in Kubernetes and sealed with the enclave's key.
func (s *Sealer) UnsealEncryptionKey(encryptedKey, additionalData []byte) ([]byte, error) {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Unsealing encryption key")

	if s.keyEncryptionKey == nil {
		// Try to get KEK from distributed storage
		s.log.Debug("Key encryption key not set: trying to load it from backend")
		sealedKEK, err := s.keyHandler.getKey(context.Background())
		if err != nil {
			return nil, fmt.Errorf("KEK not set: loading sealed KEK from backend: %w", err)
		}

		// If a KEK was found we should be able to unseal it
		s.log.Debug("Trying to unseal key encryption key")
		kek, err := s.unseal(sealedKEK, nil)
		if err != nil {
			s.log.Debug("Failed to unseal encryption key, trying to unseal with 128 bit key", zap.Error(err))
			kek, err = s.unsealFallBack(sealedKEK, nil)
			if err != nil {
				return nil, fmt.Errorf("KEK not set: unsealing KEK: %w", err)
			}
		}
		s.keyEncryptionKey = kek
	}

	s.log.Debug("Key encryption key loaded, decrypting encryption key")
	return ecrypto.Decrypt(encryptedKey, s.keyEncryptionKey, additionalData)
}

// SetEncryptionKey sets the encryption key for the sealer.
func (s *Sealer) SetEncryptionKey(key []byte) {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Setting encryption key")
	s.encryptionKey = key
	s.Sealer.SetEncryptionKey(key)
}

// SealEncryptionKey seals the sealer's encryption key using the sealer's key encryption key.
func (s *Sealer) SealEncryptionKey(additionalData []byte, _ seal.Mode) ([]byte, error) {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Sealing encryption key")

	// If the KEK is not set, generate a new one
	if s.keyEncryptionKey == nil {
		s.log.Debug("Key encryption key not set: generating a new one")
		key, err := seal.GenerateEncryptionKey()
		if err != nil {
			return nil, err
		}
		s.keyEncryptionKey = key
	}

	// Seal encryption key using the KEK
	s.log.Debug("Key encryption key loaded, encrypting encryption key")
	return ecrypto.Encrypt(s.encryptionKey, s.keyEncryptionKey, additionalData)
}

// SealKEK seals the sealer's key encryption key using the enclave's product or unique key (if not disabled).
func (s *Sealer) SealKEK(ctx context.Context, mode seal.Mode) error {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Sealing key encryption key", zap.Int("sealMode", int(mode)))
	s.mode = mode
	return s.sealKEK(ctx)
}

// SetSealMode sets the sealing mode.
func (s *Sealer) SetSealMode(mode seal.Mode) {
	s.mux.Lock()
	defer s.mux.Unlock()
	s.log.Debug("Setting seal mode", zap.Int("sealMode", int(mode)))
	s.mode = mode
}

// sealKEK seals the sealer's key encryption key using the enclave's product or unique key (if not disabled).
// We do this so the KEK can be unsealed by any Coordinator running on the same node.
// The Caller must hold s.mux.
func (s *Sealer) sealKEK(ctx context.Context) error {
	// We enable sealing with the unique key also for ModeDisabled because if the Coordinator is
	// restarted before a manifest is set, it will go into recovery mode if it can't unseal the KEK.
	sealWithSelectedKey := s.sealWithUniqueKey
	if s.mode == seal.ModeProductKey {
		sealWithSelectedKey = s.sealWithProductKey
	}

	sealedKEK, err := sealWithSelectedKey(s.keyEncryptionKey, nil)
	if err != nil {
		return fmt.Errorf("sealing KEK: %w", err)
	}

	s.log.Debug("Saving sealed key encryption key to backend")
	if err := s.keyHandler.setKey(ctx, sealedKEK); err != nil {
		return fmt.Errorf("saving sealed KEK to backend: %w", err)
	}
	return nil
}

type sealFunc func(plaintext, extraData []byte) ([]byte, error)

// k8sKeyHandler handles storing and retrieving key encryption keys from Kubernetes ConfigMaps.
type k8sKeyHandler struct {
	client kubectl

	keyID      string
	configName string
	namespace  string
	log        *zap.Logger
}

func newK8sKeyHandler(client kubectl, configName, nameSpace string, log *zap.Logger) (*k8sKeyHandler, error) {
	keyID, err := enclave.GetSealKeyID()
	if err != nil {
		return nil, fmt.Errorf("creating key ID: %w", err)
	}

	return &k8sKeyHandler{
		client:     client,
		keyID:      hex.EncodeToString(keyID),
		configName: configName,
		namespace:  nameSpace,
		log:        log,
	}, nil
}

// getKey retrieves the key for the current node from the ConfigMap.
func (k *k8sKeyHandler) getKey(ctx context.Context) ([]byte, error) {
	k.log.Debug("Retrieving key encryption key ConfigMap", zap.String("namespace", k.namespace), zap.String("name", k.configName))
	configMap, err := k.client.getConfigMap(ctx, k.namespace, k.configName)
	if err != nil {
		return nil, err
	}

	k.log.Debug("Retrieving key from ConfigMap", zap.String("keyID", k.keyID))
	key, ok := configMap.BinaryData[k.keyID]
	if !ok {
		return nil, errors.New("key not found in ConfigMap")
	}
	return key, nil
}

// setKey stores the key for the current node in the ConfigMap.
func (k *k8sKeyHandler) setKey(ctx context.Context, key []byte) error {
	// Check if configMap already exists
	k.log.Debug("Setting key in key encryption key in ConfigMap", zap.String("namespace", k.namespace), zap.String("name", k.configName), zap.String("keyID", k.keyID))
	k.log.Debug("Retrieving key encryption key ConfigMap", zap.String("namespace", k.namespace), zap.String("name", k.configName))
	cfg, err := k.client.getConfigMap(ctx, k.namespace, k.configName)
	if err != nil {
		if !k8serrors.IsNotFound(err) {
			return err
		}

		// Create new ConfigMap if it does not exist
		k.log.Debug("Creating new key encryption key ConfigMap", zap.String("namespace", k.namespace), zap.String("name", k.configName))
		binData := make(map[string][]byte)
		binData[k.keyID] = key

		return k.client.createConfigMap(ctx, k.namespace, &corev1.ConfigMap{
			ObjectMeta: metav1.ObjectMeta{
				Name:      k.configName,
				Namespace: k.namespace,
			},
			BinaryData: binData,
		})
	}

	k.log.Debug("Patching ConfigMap with new key", zap.String("keyID", k.keyID))
	patchValues := []any{
		patchByteValue{
			Op:    "add",
			Path:  fmt.Sprintf("/binaryData/%s", k.keyID),
			Value: key,
		},
	}

	// If the ConfigMap is missing the BinaryData field we need to add it
	if cfg.BinaryData == nil {
		patchValues = append([]any{
			patchMapValue{
				Op:    "add",
				Path:  "/binaryData",
				Value: make(map[string][]byte),
			},
		}, patchValues...)
	}

	patch, err := json.Marshal(patchValues)
	if err != nil {
		return err
	}

	return k.client.patchConfigMapKey(ctx, k.namespace, k.configName, patch)
}

// keyHandler is an interface for storing and retrieving keys.
type keyHandler interface {
	getKey(ctx context.Context) ([]byte, error)
	setKey(ctx context.Context, key []byte) error
}

type kubeClient struct {
	client kubernetes.Interface
}

// createConfigMap creates a new ConfigMap.
func (c *kubeClient) createConfigMap(ctx context.Context, namespace string, config *corev1.ConfigMap) error {
	_, err := c.client.CoreV1().ConfigMaps(namespace).Create(ctx, config, metav1.CreateOptions{})
	return err
}

// getConfigMap retrieves a ConfigMap.
func (c *kubeClient) getConfigMap(ctx context.Context, namespace, name string) (*corev1.ConfigMap, error) {
	return c.client.CoreV1().ConfigMaps(namespace).Get(ctx, name, metav1.GetOptions{})
}

// patchConfigMapKey patches a single key in a ConfigMap.
func (c *kubeClient) patchConfigMapKey(ctx context.Context, namespace, name string, patch []byte) error {
	_, err := c.client.CoreV1().ConfigMaps(namespace).Patch(ctx, name, types.JSONPatchType, patch, metav1.PatchOptions{})
	return err
}

type kubectl interface {
	createConfigMap(ctx context.Context, namespace string, secret *corev1.ConfigMap) error
	getConfigMap(ctx context.Context, namespace, name string) (*corev1.ConfigMap, error)
	patchConfigMapKey(ctx context.Context, namespace, name string, patch []byte) error
}

type patchMapValue struct {
	Op    string            `json:"op"`
	Path  string            `json:"path"`
	Value map[string][]byte `json:"value"`
}

type patchByteValue struct {
	Op    string `json:"op"`
	Path  string `json:"path"`
	Value []byte `json:"value"`
}
