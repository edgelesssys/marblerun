# Secrets management

Two of the *Coordinator*'s central duties are the generation and the management of secrets for the marbles (i.e., containers running enclaves). Specifically, the *Coordinator* deals with the following types of marble secrets.

* [Virtual sealing keys](#virtual-sealing-keys)
* [Shared symmetric keys](#shared-symmetric-keys)
* [Private keys for TLS](#private-keys-for-tls)

All of these secrets are handed to marbles via placeholders in the manifest as is described [here](set-manifest.md).

## Virtual sealing keys

A key feature of Intel SGX is that it allows enclave software to derive so called "sealing keys". Generally, sealing keys are unique for a given enclave software / processor combination. Upon request from an enclave, the processor will deterministically derive the enclave's sealing key using a recipe somewhat reminiscent of the following: `hash(cpu_secret, hash(enclave_software), hash(enclave_parameters), ...)`. Enclave software uses sealing keys to encrypt data and persist it to local disk. This process is also referred to as "sealing". Sealing enables enclave software to persist sensitive data locally between restarts, e.g., after crashes or system reboots.

Crucially, in SGX, the aforementioned `cpu_secret` is hard-wired in silicon and is unique per physical processor. Thus, sealing keys do no commute between processors. Particularly in cloud settings, this becomes a problem: if a VM is scheduled on a different host, enclaves running within that VM cannot unseal their local data anymore, because the host's `cpu_secret` has changed. 

To solve this problem, the Coordinator generates "virtual sealing keys" for marbles. After successful validation of a marble, the Coordinator injects a marble's virtual sealing key through the `$$seal_key` placeholder in the `Parameters` section of the manifest. 

The Coordinator derives virtual sealing keys from respective marble's ID and a master secret only known to the Coordinator. The ID is a public 128-bit value randomly generated by each marble for itself upon startup and persisted in plaintext to local storage. Given this, two marbles could end up with the same ID and virtual sealing key under certain circumstances. The security implications of this need to be taken into account when using virtual sealing keys. For example, when using virtual sealing keys with AES-GCM, one must only use cryptographically random nonces.

## Shared symmetric keys

While virtual sealing keys are used by individual marbles, Marblerun also allows for the sharing of symmetric encryption keys between marbles via placeholders in the manifest. The Coordinator creates these keys once and provides them as parameters to corresponding marbles. Marbles can use shared keys for a variety of tasks, including the bulk encryption of shared data. 

As with virtual sealing keys, care has to be taken to not repeat nonces between marbles when using shared keys with AES-GCM or similar encryption algorithms.  

## Private keys for TLS