"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9737],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},95549:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"workflows/verification","title":"Verifying a deployment","description":"MarbleRun provides a simple HTTP REST API for clients to verify the confidentiality and integrity of the Coordinator and the deployed Marbles.","source":"@site/versioned_docs/version-1.1/workflows/verification.md","sourceDirName":"workflows","slug":"/workflows/verification","permalink":"/marblerun/pr-preview/pr-919/1.1/workflows/verification","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/marblerun/edit/master/docs/versioned_docs/version-1.1/workflows/verification.md","tags":[],"version":"1.1","frontMatter":{},"sidebar":"docs","previous":{"title":"Add a service","permalink":"/marblerun/pr-preview/pr-919/1.1/workflows/add-service"},"next":{"title":"Monitoring and logging","permalink":"/marblerun/pr-preview/pr-919/1.1/workflows/monitoring"}}');var r=t(74848),o=t(28453);const s={},a="Verifying a deployment",c={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Azure QPL",id:"azure-qpl",level:3},{value:"Intel QPL",id:"intel-qpl",level:3},{value:"Establishing trust in the Coordinator",id:"establishing-trust-in-the-coordinator",level:2},{value:"Verifying the manifest",id:"verifying-the-manifest",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"verifying-a-deployment",children:"Verifying a deployment"})}),"\n",(0,r.jsx)(n.p,{children:"MarbleRun provides a simple HTTP REST API for clients to verify the confidentiality and integrity of the Coordinator and the deployed Marbles."}),"\n",(0,r.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsx)(n.p,{children:"Verifying remote attestation quotes doesn't require an SGX capable machine, however, quote provider libraries are still necessary to perform remote attestation."}),"\n",(0,r.jsx)(n.h3,{id:"azure-qpl",children:"Azure QPL"}),"\n",(0,r.jsxs)(n.p,{children:["If the quote was generated on Azure infrastructure, all you need is the ",(0,r.jsx)(n.a,{href:"https://github.com/microsoft/Azure-DCAP-Client",children:"Azure-DCAP-Client"}),". It's already configured to connect to the correct Azure-provided ",(0,r.jsx)(n.a,{href:"https://download.01.org/intel-sgx/latest/dcap-latest/linux/docs/DCAP_ECDSA_Orientation.pdf",children:"Provisioning Certificate Caching Service (PCCS)"})," endpoints."]}),"\n",(0,r.jsx)(n.p,{children:"You can install it via Microsoft's Ubuntu package repository:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add\nsudo add-apt-repository "deb [arch=amd64] https://packages.microsoft.com/ubuntu/`lsb_release -rs`/prod `lsb_release -cs` main"\nsudo apt install az-dcap-client\n'})}),"\n",(0,r.jsx)(n.h3,{id:"intel-qpl",children:"Intel QPL"}),"\n",(0,r.jsxs)(n.p,{children:["Otherwise, you can use the ",(0,r.jsx)(n.a,{href:"https://github.com/intel/confidential-computing.tee.dcap/tree/main/QuoteGeneration/qpl",children:"Intel DCAP Quote Provider Library"}),".\nYou can install the library via Intel's Ubuntu package repository:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Add the repository and key\nwget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | sudo apt-key add -\necho 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu bionic main' | sudo tee /etc/apt/sources.list.d/intel-sgx.list\n# Install the qpl\nsudo apt install libsgx-dcap-default-qpl\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Our tools build on ",(0,r.jsx)(n.a,{href:"https://github.com/openenclave/openenclave",children:"OpenEnclave"})," for quote verification, which expects the QPL as ",(0,r.jsx)(n.code,{children:"libdcap_quoteprov.so"}),".\nWe need to create a link to Intel's library:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd /usr/lib/x86_64-linux-gnu/\nsudo ln -s libdcap_quoteprov.so.1 libdcap_quoteprov.so\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To make sure the QPL connects to the correct PCCS we need to edit the ",(0,r.jsx)(n.a,{href:"https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/master/QuoteGeneration/qpl/README.md#configuration",children:"configuration"})," in ",(0,r.jsx)(n.code,{children:"/etc/sgx_default_qcnl.conf"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# PCCS server address\nPCCS_URL=<YOUR_PCCS_URL>\n# To accept insecure HTTPS cert, set this option to FALSE\nUSE_SECURE_CERT=<TRUE/FALSE>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"establishing-trust-in-the-coordinator",children:"Establishing trust in the Coordinator"}),"\n",(0,r.jsxs)(n.p,{children:["MarbleRun exposes the ",(0,r.jsx)(n.code,{children:"/quote"})," endpoint that returns a quote and a certificate chain consisting of a root and intermediate CA. The root CA is fixed for the lifetime of your deployment, while the intermediate CA changes in case you ",(0,r.jsx)(n.a,{href:"/marblerun/pr-preview/pr-919/1.1/workflows/update-manifest",children:"update"})," the packages specified in your manifest."]}),"\n",(0,r.jsxs)(n.p,{children:["The simplest way to verify the quote is via the Edgeless Remote Attestation (",(0,r.jsx)(n.a,{href:"https://github.com/edgelesssys/era",children:"era"}),") tool."]}),"\n",(0,r.jsxs)(n.p,{children:["To verify the coordinator, ",(0,r.jsx)(n.code,{children:"era"})," requires the Coordinator's UniqueID (or MRENCLAVE in SGX terms) or the tuple ProductID, SecurityVersion, SignerID (MRSIGNER) to verify the quote. ",(0,r.jsx)(n.code,{children:"era"})," contacts the Coordinator, and receives an SGX quote from it which contains the actual UniqueID or ProductID/SecurityVersion/SignerID tuple of the running instance. The tool verifies it against the expected values defined in ",(0,r.jsx)(n.code,{children:"coordinator-era.json"})," and can therefore determine if an authentic copy of the Coordinator is running, or if an unknown version is contacted."]}),"\n",(0,r.jsxs)(n.p,{children:["In production, the expected values in ",(0,r.jsx)(n.code,{children:"coordinator-era.json"})," would be generated when building the Coordinator and distributed to your clients. When you build MarbleRun from source, you can find the file in your build directory.\nFor testing with a pre-built release, there's a Coordinator image at ",(0,r.jsx)(n.code,{children:"ghcr.io/edgelesssys/marblerun/coordinator"}),".\nYou can pull the corresponding ",(0,r.jsx)(n.code,{children:"coordinator-era.json"})," file from our release page:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"wget https://github.com/edgelesssys/marblerun/releases/latest/download/coordinator-era.json\n"})}),"\n",(0,r.jsxs)(n.p,{children:["After installing ",(0,r.jsx)(n.code,{children:"era"}),", you can verify the quote with the following command:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"era -c coordinator-era.json -h $MARBLERUN -output-chain marblerun-chain.pem -output-root marblerun-root.pem -output-intermediate marblerun-intermedite.pem\n"})}),"\n",(0,r.jsxs)(n.p,{children:["After successful verification, you'll have ",(0,r.jsx)(n.code,{children:"marblerun-chain.pem"}),", ",(0,r.jsx)(n.code,{children:"marblerun-root.pem"}),", and ",(0,r.jsx)(n.code,{children:"marblerun-intermediate.pem"})," in your directory. In case you want to pin against specific versions of your application, using the intermediate CA as a trust anchor is a good choice. Else you can pin against the root CA in which case different versions of your application can talk with each other. However, you may not be able to launch them if they don't meet the minimum ",(0,r.jsx)(n.code,{children:"SecurityVersion"})," specified in your original or updated manifest."]}),"\n",(0,r.jsx)(n.h2,{id:"verifying-the-manifest",children:"Verifying the manifest"}),"\n",(0,r.jsxs)(n.p,{children:["Establishing trust with the service mesh allows you to verify the deployed manifest in the second step.\nTo that end, MarbleRun exposes the endpoint ",(0,r.jsx)(n.code,{children:"/manifest"}),".\nUsing the CLI, you can get the manifest's signature and compare it against your local version of the manifest which should have been provided to you by the operator."]}),"\n",(0,r.jsxs)(n.p,{children:["You can verify your local ",(0,r.jsx)(n.code,{children:"manifest.json"})," against the Coordinator's version with the following command:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"marblerun manifest verify manifest.json $MARBLERUN\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);