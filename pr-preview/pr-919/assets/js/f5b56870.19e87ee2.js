"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5644],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},81511:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"features/kubernetes-integration","title":"Kubernetes integration","description":"MarbleRun provides its data-plane configuration through Kubernetes resource definitions. Like regular service meshes, MarbleRun uses Kubernetes\' admission controllers.","source":"@site/versioned_docs/version-1.2/features/kubernetes-integration.md","sourceDirName":"features","slug":"/features/kubernetes-integration","permalink":"/marblerun/pr-preview/pr-919/1.2/features/kubernetes-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/marblerun/edit/master/docs/versioned_docs/version-1.2/features/kubernetes-integration.md","tags":[],"version":"1.2","frontMatter":{},"sidebar":"docs","previous":{"title":"Transparent TLS","permalink":"/marblerun/pr-preview/pr-919/1.2/features/transparent-TLS"},"next":{"title":"Supported runtimes","permalink":"/marblerun/pr-preview/pr-919/1.2/features/runtimes"}}');var s=r(74848),i=r(28453);const a={},o="Kubernetes integration",l={},c=[{value:"The <code>marbletype</code> label",id:"the-marbletype-label",level:2},{value:"The <code>marblecontainer</code> label",id:"the-marblecontainer-label",level:2},{value:"The <code>resource-injection</code> label",id:"the-resource-injection-label",level:2},{value:"Injected environment variables",id:"injected-environment-variables",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"kubernetes-integration",children:"Kubernetes integration"})}),"\n",(0,s.jsxs)(n.p,{children:["MarbleRun provides its data-plane configuration through Kubernetes resource definitions. Like regular service meshes, MarbleRun uses Kubernetes' ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook",children:"admission controllers"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["MarbleRun optionally injects ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/",children:"tolerations"})," and ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",children:"resources"})," for its SGX device plugin. See the ",(0,s.jsx)(n.a,{href:"/marblerun/pr-preview/pr-919/1.2/deployment/kubernetes#sgx-device-plugin-on-kubernetes",children:"Kubernetes deployment"})," section for more information."]}),"\n",(0,s.jsx)(n.p,{children:"You can enable auto-injection of the data-plane configuration using Pod labels."}),"\n",(0,s.jsxs)(n.h2,{id:"the-marbletype-label",children:["The ",(0,s.jsx)(n.code,{children:"marbletype"})," label"]}),"\n",(0,s.jsxs)(n.p,{children:["In MarbleRun, Marbles (i.e., secure enclaves) are defined in the ",(0,s.jsx)(n.a,{href:"/marblerun/pr-preview/pr-919/1.2/workflows/define-manifest",children:"manifest"}),". You need to reference Marbles in your Kubernetes resource description as follows using the ",(0,s.jsx)(n.code,{children:"marblerun/marbletype"})," label:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'{\n    "Marbles": {\n        "voting-svc": {\n    // ...\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: voting\n  namespace: emojivoto\n  labels:\n    app.kubernetes.io/name: voting\n    app.kubernetes.io/part-of: emojivoto\n    app.kubernetes.io/version: v1\n    marblerun/marbletype: voting-svc\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The label is used to map Kubernetes Pods to MarbleRun Marbles.\nWhen you deploy your application with the ",(0,s.jsx)(n.code,{children:"marblerun/marbletype"})," label, the Pod's creation is intercepted by MarbleRun.\nIt will then inject environment variables and SGX resources into the Pod containers based on the label's value.\nThe Pod's injection is skipped if the ",(0,s.jsx)(n.code,{children:"marblerun/marbletype"})," label is missing."]}),"\n",(0,s.jsxs)(n.h2,{id:"the-marblecontainer-label",children:["The ",(0,s.jsx)(n.code,{children:"marblecontainer"})," label"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, MarbleRun will inject environment variables and resource requests into all containers of the Pod.\nYou can use the ",(0,s.jsx)(n.code,{children:"marblerun/marblecontainer=<ContainerName>"})," label to limit injection to the specified container.\nThis is useful if your configuration uses multiple containers in the same Pod, e.g., a sidecar proxy, and you wish to prevent non-enclave containers from taking up resources."]}),"\n",(0,s.jsxs)(n.h2,{id:"the-resource-injection-label",children:["The ",(0,s.jsx)(n.code,{children:"resource-injection"})," label"]}),"\n",(0,s.jsxs)(n.p,{children:["To prevent MarbleRun from injecting SGX resource requests, you can set the label ",(0,s.jsx)(n.code,{children:"marblerun/resource-injection=disabled"}),".\nUse this if you want to set your own SGX resource requests or if you need to start a Marble in simulation mode without any SGX resources."]}),"\n",(0,s.jsx)(n.h2,{id:"injected-environment-variables",children:"Injected environment variables"}),"\n",(0,s.jsx)(n.p,{children:"The webhook will inject the following environment variables into each container of a pod:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDG_MARBLE_TYPE"}),":  The value of the ",(0,s.jsx)(n.code,{children:"marblerun/marbletype"})," label"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDG_MARBLE_COORDINATOR_ADDR"}),":  The address of the MarbleRun Coordinator running on the cluster"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDG_MARBLE_DNS_NAMES"}),":  DNS names of the pod are derived from ",(0,s.jsx)(n.code,{children:"marbletype"})," and namespace: ",(0,s.jsx)(n.code,{children:"marbletype, marbletype.namespace, marbletype.namespace.svc.cluster.local"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"EDG_MARBLE_UUID_FILE"}),":  The mounted UUID of the Marble"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If an environment variable is already set before the webhook handles the creation request, the variable won't be overwritten, and the custom value is used instead."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);