"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[273],{28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>o});var i=r(96540);const n={},a=i.createContext(n);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},44923:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/security_architecture-cc588bcf10227634bbe09c72be88d92d.svg"},72223:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/cert-chain-cd5982cb3749a86f334b4135fb5d03e6.svg"},95263:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/enc-state-distributed-00216f72449c384481d33c1929986804.svg"},96241:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"architecture/security","title":"Key management and cryptographic primitives","description":"MarbleRun protects and isolates your deployments and workloads. To that end, cryptography is the foundation that ensures the confidentiality and integrity of all components.","source":"@site/versioned_docs/version-1.9/architecture/security.md","sourceDirName":"architecture","slug":"/architecture/security","permalink":"/marblerun/pr-preview/pr-932/architecture/security","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/marblerun/edit/master/docs/versioned_docs/version-1.9/architecture/security.md","tags":[],"version":"1.9","frontMatter":{},"sidebar":"docs","previous":{"title":"Marbles","permalink":"/marblerun/pr-preview/pr-932/architecture/marbles"},"next":{"title":"EGo","permalink":"/marblerun/pr-preview/pr-932/building-marbles/ego"}}');var n=r(74848),a=r(28453);const s={},o="Key management and cryptographic primitives",c={},h=[{value:"High-level architecture",id:"high-level-architecture",level:2},{value:"Authentication and authorization",id:"authentication-and-authorization",level:2},{value:"Public key infrastructure and certificate authority",id:"public-key-infrastructure-and-certificate-authority",level:2},{value:"Attested TLS (aTLS)",id:"attested-tls-atls",level:2},{value:"Encryption of state",id:"encryption-of-state",level:2},{value:"Distributed Coordinator",id:"distributed-coordinator",level:3},{value:"Seal key",id:"seal-key",level:3}];function l(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"key-management-and-cryptographic-primitives",children:"Key management and cryptographic primitives"})}),"\n",(0,n.jsx)(t.p,{children:"MarbleRun protects and isolates your deployments and workloads. To that end, cryptography is the foundation that ensures the confidentiality and integrity of all components.\nEvaluating the security of MarbleRun requires a precise understanding of the cryptographic primitives and keys used.\nThe following gives an overview of the architecture and explains the technical details."}),"\n",(0,n.jsx)(t.h2,{id:"high-level-architecture",children:"High-level architecture"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/architecture/coordinator",children:"Coordinator"})," and the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/architecture/marbles",children:"Marbles"})," run inside SGX Enclaves. See ",(0,n.jsx)(t.a,{href:"https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html",children:"Intel's documentation"})," on the architecture details and cryptographic primitives of SGX."]}),"\n",(0,n.jsx)(t.p,{children:"MarbleRun uses cryptography for the following tasks."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Authentication and authorization"}),"\n",(0,n.jsx)(t.li,{children:"Establishment of a public key infrastructure (PKI) for MarbleRun"}),"\n",(0,n.jsx)(t.li,{children:"Encryption of network traffic via mutual TLS between enclaves"}),"\n",(0,n.jsx)(t.li,{children:"Encrypting persistent state"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The following diagram gives an overview of the architecture and the components."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Security architecture",src:r(44923).A+"",width:"1500",height:"810"})}),"\n",(0,n.jsx)(t.h2,{id:"authentication-and-authorization",children:"Authentication and authorization"}),"\n",(0,n.jsxs)(t.p,{children:["MarbleRun uses the SGX ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/attestation",children:"remote attestation"})," capability to authenticate the Coordinator and the Marble enclaves.\nFor authorization, the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/manifest",children:"manifest"})," defines the Marble's access to secrets and keys after successful attestation.\nFurthermore, MarbleRun's ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/workflows/define-manifest#roles",children:"RBAC"})," attaches ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/workflows/define-manifest#users",children:"users'"})," identities to roles in the manifest.\nEach role is associated with a set of operations the user can perform in the deployment.\nUsers are authenticated by the Coordinator using an RSA or ECDSA public key defined in the manifest."]}),"\n",(0,n.jsx)(t.h2,{id:"public-key-infrastructure-and-certificate-authority",children:"Public key infrastructure and certificate authority"}),"\n",(0,n.jsxs)(t.p,{children:["The Coordinator establishes a public key infrastructure (PKI) for MarbleRun and acts as the certificate authority (CA).\nThe goal of the PKI is to make authentication of confidential applications based on remote attestation accessible and usable.\nThe Coordinator provides an ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/reference/coordinator",children:"API"})," for retrieving an SGX attestation statement that embeds its ",(0,n.jsx)(t.em,{children:"Root CA Certificate"})," in the user-defined body.\nBy verifying the statement, clients can verify the certificate's authenticity and, thereby, the MarbleRun CA.\nSee the ",(0,n.jsx)(t.a,{href:"#attested-tls-atls",children:"attested TLS"})," section for details behind that concept.\nAll MarbleRun clients and Marbles can then use the attested ",(0,n.jsx)(t.em,{children:"Root CA Certificate"})," for authenticating TLS connections.\nThis is further illustrated conceptually in the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/attestation",children:"attestation"})," section. The following focuses on the cryptographic primitives.\nThe Coordinator generates a root X.509 certificate and corresponding asymmetric key pair during initialization.\nThe ",(0,n.jsx)(t.a,{href:"https://www.secg.org/sec1-v2.pdf#page=49",children:"Elliptic Curve Digital Signature Algorithm (ECDSA)"})," is used with curve ",(0,n.jsx)(t.a,{href:"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf#page=113",children:"P384"}),".\nThe ",(0,n.jsx)(t.em,{children:"Root CA Certificate"})," has no expiry date and lives as long as the MarbleRun deployment."]}),"\n",(0,n.jsxs)(t.p,{children:["Alongside the ",(0,n.jsx)(t.em,{children:"Root CA Certificate"}),", the Coordinator generates an X.509 ",(0,n.jsx)(t.em,{children:"Intermediate Certificate"})," and corresponding asymmetric key pair, again using ECDSA with P384.\nThe ",(0,n.jsx)(t.em,{children:"Intermediate Certificate"})," is signed by the Coordinator's ",(0,n.jsx)(t.em,{children:"Root CA Certificate"})," and rotated with every manifest update.\nWhen you push an update to the manifest (for example, bump up the ",(0,n.jsx)(t.em,{children:"SecurityVersion"})," of a Marble), the ",(0,n.jsx)(t.em,{children:"Intermediate Certificate"})," will change.\nMarble instances of the new version won't authenticate with instances of the old version and vice versa.\nHence, no data flow is happening between different ",(0,n.jsx)(t.em,{children:"SecurityVersions"})," of your application.\nHowever, the ",(0,n.jsx)(t.em,{children:"Root CA Certificate"})," doesn't change. So you can still verify the Coordinator and your application from the outside and ensure it's the same instance you might have interacted with.\nApplications interacting with the MarbleRun deployment should use the intermediate certificate as CA to make manifest updates observable:\nIf the manifest changes, connections to the deployment will fail.\nThe application user can then review the changes and install the new intermediate certificate to approve them.\nIf such observability isn't required, the application can use the root certificate as CA.\nIn that case, the application will continue to work even if the manifest changes."]}),"\n",(0,n.jsxs)(t.p,{children:["The Coordinator creates a second certificate with the same key material as the ",(0,n.jsx)(t.em,{children:"Intermediate Certificate"})," called the ",(0,n.jsx)(t.em,{children:"Marble Root Certificate"}),".\nIn that sense, they're siblings containing the same public key.\nHowever, while the ",(0,n.jsx)(t.em,{children:"Intermediate Certificate"})," is signed by the ",(0,n.jsx)(t.em,{children:"Root Certificate"}),", the ",(0,n.jsx)(t.em,{children:"Marble Root Certificate"})," is self-signed using its private key.\nThe goal here is to implement a  ",(0,n.jsx)(t.a,{href:"https://www.ssltrust.com.au/blog/understanding-certificate-cross-signing",children:"cross-signed certificate chain"}),".\nIn that way, the Marbles see the ",(0,n.jsx)(t.em,{children:"Marble Root Certificate"})," as a self-signed root certificate. Hence, they're dealing with a terminating certificate chain without knowing about the Coordinator's ",(0,n.jsx)(t.em,{children:"Root CA Certificate"}),'.\nThe "outside world" sees an intermediate certificate signed by the Coordinator\'s ',(0,n.jsx)(t.em,{children:"Root CA Certificate"}),".\nThe Coordinator generates a unique leaf ",(0,n.jsx)(t.em,{children:"Marble Certificate"})," and corresponding key pair using ECDSA with P384 for every Marble.\nThe ",(0,n.jsx)(t.em,{children:"Marble Root Certificate"})," signs the ",(0,n.jsx)(t.em,{children:"Marble Certificate"}),".\nThe ",(0,n.jsx)(t.em,{children:"Marble Certificate"})," is provisioned to the Marble's enclave via the secure channel established during the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/attestation",children:"attestation procedure"}),".\nDepending on the Marble's runtime, the certificate can be used ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/workflows/add-service#make-your-service-use-the-provided-tls-credentials",children:"manually"})," or ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/transparent-TLS",children:"automatically"})," to establish mutually authenticated TLS connections."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"PKI Certificate chain",src:r(72223).A+"",width:"1171",height:"684"})}),"\n",(0,n.jsx)(t.h2,{id:"attested-tls-atls",children:"Attested TLS (aTLS)"}),"\n",(0,n.jsx)(t.p,{children:"In a confidential computing environment, attested TLS (aTLS) can establish secure connections between two parties using the remote attestation features of the confidential computing components.\nWith aTLS, the party to be authenticated binds its TLS certificate to an attestation statement.\nFor example, it embeds the certificate's public key into the attestation statement.\nInstead of relying on a certificate authority, aTLS uses this attestation statement to establish trust in the certificate.\nThe protocol can be used by clients to verify a server certificate, by a server to verify a client certificate, or for mutual verification (mutual aTLS)."}),"\n",(0,n.jsx)(t.h2,{id:"encryption-of-state",children:"Encryption of state"}),"\n",(0,n.jsxs)(t.p,{children:["The Coordinator holds MarbleRun's state, which consists of the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/manifest",children:"manifest"}),", the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/secrets-management",children:"managed secrets"}),", and the ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/attestation",children:"certificates for its CA"}),".\nThe state is stored encrypted in persistent storage. For this, MarbleRun uses ",(0,n.jsx)(t.a,{href:"https://www.rfc-editor.org/rfc/rfc5116#section-5.2",children:"AES256-GCM"})," and a generated 32-byte data encryption key (DEK).\nThe Coordinator encrypts the DEK with a key encryption key (KEK).\nMarbleRun uses an ",(0,n.jsx)(t.a,{href:"#seal-key",children:"SGX seal key"})," as its KEK.\nHence, if the Coordinator is restarted on the same CPU, it can obtain the same KEK from the CPU, decrypt the DEK, and recover its state autonomously."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Encrypted state single instance",src:r(96748).A+"",width:"521",height:"381"})}),"\n",(0,n.jsxs)(t.p,{children:["If the Coordinator is restarted on a different CPU, it won't be able to obtain the same SGX seal key from the CPU.\nTo address this, MarbleRun provides a ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/recovery#recovery",children:"recovery feature"}),".\nThe manifest allows for specifying a designated Recovery Key. The Recovery Key is a RSA public key. Upon startup, the Coordinator encrypts the DEK with this public key and returns it to the user.\nIn case of a recovery event, the user decrypts the DEK locally and ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/workflows/recover-coordinator",children:"uploads it to the Coordinator"}),".\nThe Coordinator will decrypt the state with the DEK and proceed with operations."]}),"\n",(0,n.jsxs)(t.p,{children:["For ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/recovery#multi-party-recovery",children:"multi-party use cases"}),", MarbleRun allows splitting the Recovery Key between parties.\nEvery recovery party is defined in the manifest with its own public RSA key.\nThe Coordinator generates a share of the recovery secret for every party and encrypts it with the corresponding RSA key.\nDuring a recovery event, every party will upload their share of the secret, which are all XORed together by the Coordinator to receive the combined key for decrypting the DEK."]}),"\n",(0,n.jsx)(t.h3,{id:"distributed-coordinator",children:"Distributed Coordinator"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/features/recovery#distributed-coordinator",children:"distributed Coordinator"})," works similarly. However, all Coordinators share the same state stored encrypted in the Kubernetes ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"Secret"})," called ",(0,n.jsx)(t.em,{children:"marblerun-state"}),".\nIn contrast to the single instance, the KEK is generated at start-up by the first instance.\nThe existing Coordinators authenticate every new Coordinator instance via remote attestation, and the KEK is subsequently shared via the secure and attested TLS connection.\nEvery Coordinator instance uses an SGX seal key to seal the KEK into a Kubernetes ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/configmap/",children:"ConfigMap"})," called ",(0,n.jsx)(t.em,{children:"marblerun-sealed-kek"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Encrypted state distributed",src:r(95263).A+"",width:"891",height:"531"})}),"\n",(0,n.jsx)(t.h3,{id:"seal-key",children:"Seal key"}),"\n",(0,n.jsxs)(t.p,{children:["There are two types of ",(0,n.jsx)(t.a,{href:"https://www.intel.com/content/www/us/en/developer/articles/technical/introduction-to-intel-sgx-sealing.html",children:"SGX seal keys"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Unique key: This key is derived from the UniqueID (MRENCLAVE) of the enclave. This means that only instances of the same enclave can derive this key."}),"\n",(0,n.jsx)(t.li,{children:"Product key: This key is derived from the SignerID (MRSIGNER), ProductID, and SecurityVersion of the enclave. If the signer of the enclave creates a new enclave with the same ProductID and the same or higher SecurityVersion, that enclave can derive the same key."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["By default, MarbleRun uses the product key as the KEK.\nThis allows the Coordinator to be updated without manual recovery.\nIf you don't want to trust the signing entity, you can ",(0,n.jsx)(t.a,{href:"/marblerun/pr-preview/pr-932/workflows/define-manifest#config",children:"enable sealing with the unique key"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},96748:(e,t,r)=>{r.d(t,{A:()=>i});const i=r.p+"assets/images/enc-state-single-a918aaf42a8cad37276129bb620f4bd7.svg"}}]);