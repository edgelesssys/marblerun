"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[312],{27563:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"features/recovery","title":"State and recovery","description":"Persistent storage for confidential applications in the cloud requires attention.","source":"@site/versioned_docs/version-1.4/features/recovery.md","sourceDirName":"features","slug":"/features/recovery","permalink":"/marblerun/pr-preview/pr-934/1.4/features/recovery","draft":false,"unlisted":false,"editUrl":"https://github.com/edgelesssys/marblerun/edit/master/docs/versioned_docs/version-1.4/features/recovery.md","tags":[],"version":"1.4","frontMatter":{},"sidebar":"docs","previous":{"title":"Attestation","permalink":"/marblerun/pr-preview/pr-934/1.4/features/attestation"},"next":{"title":"Secrets management","permalink":"/marblerun/pr-preview/pr-934/1.4/features/secrets-management"}}');var o=r(74848),a=r(28453);const s={},i="State and recovery",c={},l=[{value:"Single Coordinator",id:"single-coordinator",level:3},{value:"Distributed Coordinator",id:"distributed-coordinator",level:3},{value:"Recovery",id:"recovery",level:2},{value:"Multi-party recovery",id:"multi-party-recovery",level:3}];function d(e){const t={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components},{EnterpriseBanner:r}=t;return r||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("EnterpriseBanner",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"state-and-recovery",children:"State and recovery"})}),"\n",(0,o.jsx)(t.p,{children:"Persistent storage for confidential applications in the cloud requires attention.\nIf an application should be able to restart without manual intervention, it needs a way to automatically and securely obtain a secret to decrypt its state."}),"\n",(0,o.jsx)(t.p,{children:"The SGX programming model considers a single, local application running on a specific CPU.\nThe application can use the SGX seal key as its root secret.\nHowever, this binds the application and its state to the physical machine because seal keys are unique to a single CPU.\nIn sum, the usual SGX programming model isn't suited for virtual environments or distributed applications."}),"\n",(0,o.jsxs)(t.p,{children:["With MarbleRun, the Coordinator ",(0,o.jsx)(t.a,{href:"/marblerun/pr-preview/pr-934/1.4/features/secrets-management",children:"manages the Marbles' secrets"}),", and Marbles obtain them securely on start.\nThus, Marbles can be distributed and rescheduled on arbitrary machines.\nThis narrows the challenge of persistent storage down to the Coordinator itself."]}),"\n",(0,o.jsx)(t.h3,{id:"single-coordinator",children:"Single Coordinator"}),"\n",(0,o.jsxs)(t.p,{children:["The straightforward way to run MarbleRun is with a single Coordinator.\nIn this case, the state is encrypted with the SGX seal key and stored on disk.\nWhen pinned to a single host, the Coordinator can unseal its state automatically.\nHowever, a ",(0,o.jsx)(t.a,{href:"#recovery",children:"manual step"})," is required to recover the Coordinator's state when the Coordinator is moved to another physical host."]}),"\n",(0,o.jsx)(t.h3,{id:"distributed-coordinator",children:"Distributed Coordinator"}),"\n",(0,o.jsx)(r,{}),"\n",(0,o.jsxs)(t.p,{children:["When you use MarbleRun ",(0,o.jsx)(t.a,{href:"/marblerun/pr-preview/pr-934/1.4/deployment/kubernetes",children:"with Kubernetes"}),", you can scale the Coordinator to multiple instances.\nThe instances share a common state, encrypted and stored as a Kubernetes secret.\nThe encryption key is securely distributed among the Coordinator instances via attested TLS.\nAdditionally, each Coordinator encrypts the encryption key with its SGX seal key and stores it in a ConfigMap."]}),"\n",(0,o.jsx)(t.p,{children:"In this mode of operation, manual recovery is only required when"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"all Coordinator instances are stopped at the same time, and"}),"\n",(0,o.jsx)(t.li,{children:"all new instances are scheduled on new physical hosts.\nIn other words, if at least one instance is scheduled on a host where a previous instance was running, the state can be recovered automatically."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"recovery",children:"Recovery"}),"\n",(0,o.jsxs)(t.p,{children:["The manifest allows for specifying a designated ",(0,o.jsx)(t.em,{children:"Recovery Key"}),". The Recovery Key is a public RSA key. Upon startup, the Coordinator encrypts its symmetric state-encryption key with this public key. The holder of the corresponding private key can recover the Coordinator, as is described ",(0,o.jsx)(t.a,{href:"/marblerun/pr-preview/pr-934/1.4/workflows/recover-coordinator",children:"in the recovery workflow"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"caution",children:(0,o.jsx)(t.p,{children:"The Recovery Key's owner can access the Coordinator's raw state."})}),"\n",(0,o.jsx)(t.h3,{id:"multi-party-recovery",children:"Multi-party recovery"}),"\n",(0,o.jsx)(r,{}),"\n",(0,o.jsx)(t.p,{children:"Depending on the use case, it may not be acceptable that the owner has full control over the cluster.\nMarbleRun supports splitting the Recovery Key between parties.\nOnly if all parties agree can they recover a cluster or access the raw state."})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>i});var n=r(96540);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);