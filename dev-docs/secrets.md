# MarbleRun secrets and keys

Logically, one can distinguish the following secrets:

* Key to encrypt the state (DEK)
* Key to encrypt the DEK (KEK)
* Recovery secret(s) (REC_S)
* Recovery key pair(s) (REC_PUB, REC_PRIV)
* Coordinator root key pair (ROOT_PUB, ROOT_PRIV)
* Coordinator intermediate key pair (INT_PUB, INT_PRIV)
* Coordinator root secret (RS)
* User secrets unique per Marble (UU)
* User secrets shared across Marbles (US)
* User-defined secrets (UD)

## MarbleRun

* DEK is generated when setting the initial manifest
* KEK:
  * standalone: the SGX seal key
  * distributed deployment: generated on first store commit (i.e., when setting the initial manifest or after a recovery)
* REC_S_0 XOR REC_S_1 XOR ... XOR REC_S_n = DEK
  * In case of a single recovery secret REC_S = DEK
* REC pair is generated by the user and REC_PUB is set in the manifest
* ROOT pair is generated on first start
* INT pair is generated on each manifest update
* RS is randomly generated on first start and optionally re-generated on manifest updates

## User secrets

* UU are derived from RS
* US are generated randomly once and optionally re-generated on manifest update
* UD are set by the user

## Rotation

* DEK is not rotated because it depends on the recovery secrets
* KEK is rotated on recovery
* REC_Ss and RECs are not rotated because they should be long-lived by design (generated and distributed once, stored somewhere safe, used only for disaster recovery)
* ROOT is not rotated by design. It's the identity of this exact deployment. Users can use INT if they need a rotated key.
* INT is rotated on each manifest update
* RS is only rotated when requested by a manifest update
* UU and US are only rotated when RS rotates
  * Access to the previous values is kept until RS is rotated again
* UD can be rotated by the user
